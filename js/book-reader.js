const { ipcRenderer } = require('electron');
const path = require('path');
const { spawn } = require('child_process');
const fs = require('fs');

// –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –±–∏–±–ª–∏–æ—Ç–µ–∫
let pdfParse, EPub;
try {
    pdfParse = require('pdf-parse');
    EPub = require('epub');
} catch (error) {
    console.warn('–ë–∏–±–ª–∏–æ—Ç–µ–∫–∏ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã:', error.message);
}

let currentBook = null;
let currentPage = 1;
let totalPages = 1;
let isPDF = false;
let epubInstance = null;
let bookContent = '';
let pages = [];
const CHARS_PER_PAGE = 2000;

document.addEventListener('DOMContentLoaded', function() {
    console.log('üöÄ –ß–∏—Ç–∞–ª–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç—Å—è');
    
    hideLoadingSpinner();
    loadBookData();
    setupEventListeners();
    loadReaderSettings();
});

function hideLoadingSpinner() {
    const loadingState = document.querySelector('.loading-state');
    if (loadingState) {
        loadingState.style.display = 'none';
    }
}

async function loadBookData() {
    const bookId = localStorage.getItem('currentReadingBookId');
    const bookData = localStorage.getItem('currentReadingBook');
    
    console.log('üìñ –ó–∞–≥—Ä—É–∑–∫–∞ –∫–Ω–∏–≥–∏ –¥–ª—è —á—Ç–µ–Ω–∏—è:', bookId);
    
    if (!bookId || !bookData) {
        showError('–î–∞–Ω–Ω—ã–µ –∫–Ω–∏–≥–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.');
        return;
    }
    
    try {
        currentBook = JSON.parse(bookData);
        console.log('‚úÖ –ö–Ω–∏–≥–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞:', currentBook);
        
        document.getElementById('reader-book-title').textContent = currentBook.title;
        document.getElementById('reader-book-author').textContent = currentBook.author;
        
        await loadBookContent();
        
    } catch (error) {
        console.error('‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö –∫–Ω–∏–≥–∏:', error);
        showError('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö –∫–Ω–∏–≥–∏');
    }
}

async function loadBookContent() {
    const filePath = currentBook.filePath;
    
    if (!filePath) {
        showFileNotFound();
        return;
    }
    
    console.log('üìÅ –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ç–µ–Ω—Ç–∞:', filePath);
    
    showFileInfo(filePath);
    
    const fileExists = await ipcRenderer.invoke('file-exists', filePath);
    
    if (!fileExists) {
        showFileNotFound();
        return;
    }
    
    const fileExtension = getFileExtension(filePath);
    
    if (fileExtension === 'pdf') {
        await loadPDF(filePath);
    } else if (fileExtension === 'epub') {
        await loadEPUB(filePath);
    } else if (fileExtension === 'txt') {
        await loadTXT(filePath);
    } else if (fileExtension === 'fb2') {
        await loadFB2(filePath);
    } else {
        showUnsupportedFormat();
    }
}

function getFileExtension(filePath) {
    return filePath ? filePath.split('.').pop().toLowerCase() : '';
}

function showFileInfo(filePath) {
    const textContent = document.getElementById('text-content');
    const pdfContainer = document.getElementById('pdf-container');
    
    pdfContainer.style.display = 'none';
    textContent.style.display = 'block';
    
    textContent.innerHTML = `
        <div style="text-align: center; padding: 40px;">
            <div class="loading-spinner"></div>
            <h2 style="color: #fff; margin-bottom: 15px;">–ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–∞</h2>
            <p style="color: #94a3b8;">–û–±—Ä–∞–±–æ—Ç–∫–∞: ${path.basename(filePath)}</p>
            <p style="color: #64748b; font-size: 0.9em; margin-top: 10px;">${filePath}</p>
        </div>
    `;
}

// ==================== PDF –§–£–ù–ö–¶–ò–û–ù–ê–õ ====================

async function loadPDF(filePath) {
    console.log('üìÑ –ó–∞–≥—Ä—É–∑–∫–∞ PDF:', filePath);
    isPDF = true;
    
    try {
        const absolutePath = await ipcRenderer.invoke('get-file-path', filePath);
        
        if (!absolutePath) {
            throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É');
        }
        
        console.log('üìÑ –ê–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—É—Ç—å –∫ PDF:', absolutePath);
        
        // –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ –º–µ—Ç–æ–¥—ã –ø–æ –ø–æ—Ä—è–¥–∫—É
        let success = false;
        
        // –ú–µ—Ç–æ–¥ 1: –ò—Å–ø–æ–ª—å–∑—É–µ–º pdf-parse –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω
        if (pdfParse) {
            console.log('üîÑ –ú–µ—Ç–æ–¥ 1: –ò—Å–ø–æ–ª—å–∑—É–µ–º pdf-parse');
            success = await loadPDFWithPDFParse(absolutePath);
        }
        
        // –ú–µ—Ç–æ–¥ 2: –ï—Å–ª–∏ pdf-parse –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª, –ø—Ä–æ–±—É–µ–º –ø—Ä–æ—Å—Ç–æ–π –º–µ—Ç–æ–¥
        if (!success) {
            console.log('üîÑ –ú–µ—Ç–æ–¥ 2: –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–æ—Å—Ç–æ–π –ø–∞—Ä—Å–∏–Ω–≥');
            success = await loadPDFSimple(absolutePath);
        }
        
        // –ú–µ—Ç–æ–¥ 3: –ï—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª–æ, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ñ–∞–π–ª–µ
        if (!success) {
            console.log('üîÑ –ú–µ—Ç–æ–¥ 3: –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ñ–∞–π–ª–µ');
            showPDFInfo(absolutePath);
            showMessage('PDF —Å–æ–¥–µ—Ä–∂–∏—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–ª–∏ –∑–∞—â–∏—â–µ–Ω –æ—Ç –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è', 'warning');
        }
        
    } catch (error) {
        console.error('‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ PDF:', error);
        showPDFFallback(filePath, error.message);
    }
}

async function loadPDFWithPDFParse(filePath) {
    try {
        const result = await ipcRenderer.invoke('read-binary-file', filePath);
        
        if (!result.success) {
            return false;
        }
        
        const buffer = Buffer.from(result.content, 'binary');
        const data = await pdfParse(buffer);
        
        console.log('üìä PDF –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:', {
            pages: data.numpages,
            textLength: data.text.length,
            hasText: data.text.length > 0
        });
        
        if (data.text && data.text.length > 100) {
            bookContent = data.text;
            createPagesFromText(bookContent);
            showPage(currentPage);
            showMessage(`PDF –∑–∞–≥—Ä—É–∂–µ–Ω: ${data.numpages} —Å—Ç—Ä–∞–Ω–∏—Ü`, 'success');
            return true;
        }
        
        return false;
        
    } catch (error) {
        console.error('‚ùå pdf-parse –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª:', error);
        return false;
    }
}

async function loadPDFSimple(filePath) {
    try {
        const result = await ipcRenderer.invoke('read-binary-file', filePath);
        
        if (!result.success) {
            return false;
        }
        
        const extractedText = extractTextFromPDF(result.content);
        
        if (extractedText && extractedText.length > 100) {
            bookContent = extractedText;
            createPagesFromText(bookContent);
            showPage(currentPage);
            showMessage('PDF –∑–∞–≥—Ä—É–∂–µ–Ω (–ø—Ä–æ—Å—Ç–æ–π –º–µ—Ç–æ–¥)', 'success');
            return true;
        }
        
        return false;
        
    } catch (error) {
        console.error('‚ùå –ü—Ä–æ—Å—Ç–æ–π –º–µ—Ç–æ–¥ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª:', error);
        return false;
    }
}

function extractTextFromPDF(binaryData) {
    console.log('üîÑ –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –∏–∑ PDF...');
    
    const textChunks = [];
    
    try {
        // –ú–µ—Ç–æ–¥ 1: –ò—â–µ–º —Ç–µ–∫—Å—Ç –≤ —Å–∫–æ–±–∫–∞—Ö (—Å–∞–º—ã–π —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–Ω—ã–π –≤ PDF)
        const bracketText = binaryData.match(/\(([^)]+)\)/g);
        if (bracketText) {
            bracketText.forEach(match => {
                const text = match.slice(1, -1);
                // –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ —á–∏—Ç–∞–µ–º—ã–π —Ç–µ–∫—Å—Ç
                if (text.length > 2 && /[–∞-—è–ê-–Øa-zA-Z]/.test(text)) {
                    textChunks.push(text);
                }
            });
        }
        
        // –ú–µ—Ç–æ–¥ 2: –ò—â–µ–º –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –±—É–∫–≤
        const wordPattern = /[–∞-—è–ê-–Øa-zA-Z][–∞-—è–ê-–Øa-zA-Z\s.,!?;:"'\-()]{5,}/g;
        const wordMatches = binaryData.match(wordPattern);
        if (wordMatches) {
            wordMatches.forEach(text => {
                const cleanText = text.trim();
                if (cleanText.length > 5) {
                    textChunks.push(cleanText);
                }
            });
        }
        
        // –ú–µ—Ç–æ–¥ 3: –ò—â–µ–º hex-encoded —Ç–µ–∫—Å—Ç
        const hexPattern = /<([0-9A-Fa-f\s]+)>/g;
        const hexMatches = binaryData.match(hexPattern);
        if (hexMatches) {
            hexMatches.forEach(match => {
                const hex = match.slice(1, -1).replace(/\s/g, '');
                if (hex.length >= 4) {
                    try {
                        const text = hexToText(hex);
                        if (text.length > 3 && /[–∞-—è–ê-–Øa-zA-Z]/.test(text)) {
                            textChunks.push(text);
                        }
                    } catch (e) {
                        // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏
                    }
                }
            });
        }
        
        const result = textChunks.join(' ').substring(0, 50000);
        console.log(`üìù –ò–∑–≤–ª–µ—á–µ–Ω–æ —Ç–µ–∫—Å—Ç–∞: ${result.length} —Å–∏–º–≤–æ–ª–æ–≤`);
        
        return result.length > 100 ? result : null;
        
    } catch (error) {
        console.error('‚ùå –û—à–∏–±–∫–∞ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è —Ç–µ–∫—Å—Ç–∞:', error);
        return null;
    }
}

function hexToText(hex) {
    let text = '';
    for (let i = 0; i < hex.length; i += 2) {
        const byte = hex.substr(i, 2);
        if (byte.length === 2) {
            const charCode = parseInt(byte, 16);
            // –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—á–∞—Ç–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã
            if (charCode >= 32 && charCode <= 126) {
                text += String.fromCharCode(charCode);
            } else if (charCode >= 1040 && charCode <= 1103) {
                // –ö–∏—Ä–∏–ª–ª–∏—á–µ—Å–∫–∏–µ —Å–∏–º–≤–æ–ª—ã
                text += String.fromCharCode(charCode);
            }
        }
    }
    return text;
}

function showPDFInfo(filePath) {
    const textContent = document.getElementById('text-content');
    
    textContent.innerHTML = `
        <div style="max-width: 800px; margin: 0 auto; padding: 40px;">
            <div style="text-align: center; margin-bottom: 40px;">
                <div style="font-size: 64px; margin-bottom: 20px;">üìÑ</div>
                <h1 style="color: #fff; margin-bottom: 10px;">${currentBook.title}</h1>
                <h2 style="color: #94a3b8; margin-bottom: 20px;">${currentBook.author}</h2>
            </div>
            
            <div style="background: rgba(251, 191, 36, 0.1); padding: 25px; border-radius: 12px; margin-bottom: 25px;">
                <h3 style="color: #fbbf24; margin-bottom: 15px;">üìä –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ PDF —Ñ–∞–π–ª–µ</h3>
                <div style="color: #fbbf24; line-height: 1.6;">
                    <p><strong>–§–∞–π–ª:</strong> ${path.basename(filePath)}</p>
                    <p><strong>–ü—É—Ç—å:</strong> ${filePath}</p>
                    <p><strong>–°—Ç–∞—Ç—É—Å:</strong> –§–∞–π–ª –∑–∞–≥—Ä—É–∂–µ–Ω, –Ω–æ —Ç–µ–∫—Å—Ç –Ω–µ –∏–∑–≤–ª–µ—á–µ–Ω</p>
                </div>
            </div>
            
            <div style="background: rgba(59, 130, 246, 0.1); padding: 20px; border-radius: 8px; margin-bottom: 25px;">
                <h4 style="color: #3b82f6; margin-bottom: 15px;">üí° –í–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã:</h4>
                <ul style="color: #3b82f6; text-align: left; padding-left: 20px;">
                    <li>PDF —Å–æ–¥–µ—Ä–∂–∏—Ç —Ç–µ–∫—Å—Ç –≤ –≤–∏–¥–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π (—Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã)</li>
                    <li>–§–∞–π–ª –∑–∞—â–∏—â–µ–Ω –æ—Ç –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è —Ç–µ–∫—Å—Ç–∞</li>
                    <li>–ò—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —à—Ä–∏—Ñ—Ç—ã</li>
                    <li>–§–∞–π–ª –ø–æ–≤—Ä–µ–∂–¥–µ–Ω –∏–ª–∏ –∏–º–µ–µ—Ç –Ω–µ—Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç</li>
                </ul>
            </div>
            
            <div style="text-align: center;">
                <button class="reader-control-btn" onclick="openInSystemViewer('${filePath}')" style="margin: 10px;">
                    üìÇ –û—Ç–∫—Ä—ã—Ç—å –≤ —Å–∏—Å—Ç–µ–º–Ω–æ–º –ø—Ä–æ—Å–º–æ—Ç—Ä—â–∏–∫–µ
                </button>
                <button class="reader-control-btn" onclick="convertPDFToText('${filePath}')" style="margin: 10px;">
                    üîÑ –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å OCR (—ç–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç–∞–ª—å–Ω–æ)
                </button>
            </div>
        </div>
    `;
}

// ==================== EPUB –§–£–ù–ö–¶–ò–û–ù–ê–õ ====================

async function loadEPUB(filePath) {
    console.log('üìñ –ó–∞–≥—Ä—É–∑–∫–∞ EPUB:', filePath);
    isPDF = false;
    
    if (!EPub) {
        showEPUBFallback(filePath, '–ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ epub –Ω–µ –¥–æ—Å—Ç—É–ø–Ω–∞');
        return;
    }
    
    try {
        const absolutePath = await ipcRenderer.invoke('get-file-path', filePath);
        epubInstance = new EPub(absolutePath);
        await parseEPUB(epubInstance);
        
    } catch (error) {
        console.error('‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ EPUB:', error);
        showEPUBFallback(filePath, error.message);
    }
}

function parseEPUB(epub) {
    return new Promise((resolve, reject) => {
        let fullText = '';
        
        epub.on('end', function() {
            console.log('‚úÖ EPUB –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã');
            
            let chaptersProcessed = 0;
            const totalChapters = epub.flow.length;
            
            if (totalChapters === 0) {
                reject(new Error('–í EPUB —Ñ–∞–π–ª–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –≥–ª–∞–≤'));
                return;
            }
            
            epub.flow.forEach(function(chapter) {
                epub.getChapter(chapter.id, function(error, text) {
                    chaptersProcessed++;
                    
                    if (!error && text) {
                        const cleanText = stripHtmlTags(text);
                        fullText += cleanText + '\n\n';
                    }
                    
                    if (chaptersProcessed === totalChapters) {
                        bookContent = fullText;
                        createPagesFromText(bookContent);
                        showPage(currentPage);
                        showMessage(`EPUB –∑–∞–≥—Ä—É–∂–µ–Ω: ${totalChapters} –≥–ª–∞–≤`, 'success');
                        resolve();
                    }
                });
            });
        });
        
        epub.on('error', reject);
        epub.parse();
    });
}

// ==================== –¢–ï–ö–°–¢–û–í–´–ï –§–û–†–ú–ê–¢–´ ====================

async function loadTXT(filePath) {
    console.log('üìù –ó–∞–≥—Ä—É–∑–∫–∞ TXT:', filePath);
    isPDF = false;
    
    try {
        const result = await ipcRenderer.invoke('read-file', filePath);
        
        if (result.success) {
            bookContent = result.content;
            createPagesFromText(bookContent);
            showPage(currentPage);
            showMessage('–¢–µ–∫—Å—Ç–æ–≤—ã–π —Ñ–∞–π–ª –∑–∞–≥—Ä—É–∂–µ–Ω', 'success');
        } else {
            throw new Error(result.error);
        }
    } catch (error) {
        console.error('‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ TXT:', error);
        showFileNotFound();
    }
}

async function loadFB2(filePath) {
    await loadEPUB(filePath);
}

// ==================== –°–ò–°–¢–ï–ú–ê –°–¢–†–ê–ù–ò–¶ ====================

function createPagesFromText(text) {
    pages = [];
    
    if (!text || text.trim().length === 0) {
        pages.push('–¢–µ–∫—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –ø—É—Å—Ç');
        totalPages = 1;
        updateNavigation();
        return;
    }
    
    // –†–∞–∑–±–∏–≤–∞–µ–º —Ç–µ–∫—Å—Ç –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
    for (let i = 0; i < text.length; i += CHARS_PER_PAGE) {
        pages.push(text.substring(i, i + CHARS_PER_PAGE));
    }
    
    totalPages = pages.length;
    console.log(`üìÑ –°–æ–∑–¥–∞–Ω–æ ${totalPages} —Å—Ç—Ä–∞–Ω–∏—Ü`);
    
    updateNavigation();
    updateProgress();
}

function showPage(pageNumber) {
    if (pageNumber < 1 || pageNumber > totalPages) return;
    
    currentPage = pageNumber;
    const pageContent = pages[pageNumber - 1];
    
    const textContent = document.getElementById('text-content');
    textContent.style.display = 'block';
    textContent.innerHTML = formatPageContent(pageContent, pageNumber);
    
    updateNavigation();
    updateProgress();
    textContent.scrollTop = 0;
}

function formatPageContent(content, pageNumber) {
    const formattedText = content
        .split('\n')
        .map(line => line.trim())
        .filter(line => line.length > 0)
        .map(line => `<p style="margin: 12px 0; line-height: 1.6; text-align: justify;">${escapeHtml(line)}</p>`)
        .join('');
    
    return `
        <div style="max-width: 900px; margin: 0 auto; padding: 30px 40px;">
            <div style="text-align: center; margin-bottom: 30px; border-bottom: 1px solid #334155; padding-bottom: 20px;">
                <h1 style="color: #fff; margin-bottom: 8px; font-size: 1.8em;">${currentBook.title}</h1>
                <h2 style="color: #94a3b8; margin-bottom: 15px; font-size: 1.2em;">${currentBook.author}</h2>
                <div style="color: #64748b; font-size: 0.9em;">–°—Ç—Ä–∞–Ω–∏—Ü–∞ ${pageNumber} –∏–∑ ${totalPages}</div>
            </div>
            
            <div style="color: #e2e8f0; min-height: 500px;">
                ${formattedText}
            </div>
            
            <div style="text-align: center; margin-top: 40px; padding-top: 20px; border-top: 1px solid #334155; color: #64748b;">
                ‚Äî ${pageNumber} ‚Äî
            </div>
        </div>
    `;
}

// ==================== –ù–ê–í–ò–ì–ê–¶–ò–Ø –ò –ò–ù–¢–ï–†–§–ï–ô–° ====================

function updateNavigation() {
    const prevBtn = document.getElementById('prev-btn');
    const nextBtn = document.getElementById('next-btn');
    const pageInfo = document.getElementById('page-info');
    
    if (prevBtn) prevBtn.disabled = currentPage <= 1;
    if (nextBtn) nextBtn.disabled = currentPage >= totalPages;
    if (pageInfo) pageInfo.textContent = `–°—Ç—Ä–∞–Ω–∏—Ü–∞: ${currentPage} / ${totalPages}`;
}

function updateProgress() {
    const progressFill = document.getElementById('progress-fill');
    const progressPercent = document.getElementById('progress-percent');
    
    if (progressFill && progressPercent) {
        const progress = (currentPage / totalPages) * 100;
        progressFill.style.width = progress + '%';
        progressPercent.textContent = Math.round(progress) + '%';
    }
}

function previousPage() {
    if (currentPage > 1) showPage(currentPage - 1);
}

function nextPage() {
    if (currentPage < totalPages) showPage(currentPage + 1);
}

function goToPage(pageNumber) {
    const page = parseInt(pageNumber);
    if (page >= 1 && page <= totalPages) showPage(page);
}

// ==================== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ====================

function stripHtmlTags(html) {
    return html.replace(/<[^>]*>/g, '').replace(/\s+/g, ' ').trim();
}

function escapeHtml(unsafe) {
    if (typeof unsafe !== 'string') return unsafe;
    return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
}

function openInSystemViewer(filePath) {
    const { shell } = require('electron');
    shell.openPath(filePath).catch(error => {
        showMessage('–û—à–∏–±–∫–∞ –æ—Ç–∫—Ä—ã—Ç–∏—è —Ñ–∞–π–ª–∞', 'error');
    });
}

// ==================== –°–û–û–ë–©–ï–ù–ò–Ø –û–ë –û–®–ò–ë–ö–ê–• ====================

function showPDFFallback(filePath, errorMessage) {
    showPDFInfo(filePath);
}

function showEPUBFallback(filePath, errorMessage) {
    const textContent = document.getElementById('text-content');
    textContent.innerHTML = `
        <div style="text-align: center; padding: 40px;">
            <div style="font-size: 64px; margin-bottom: 20px;">üìñ</div>
            <h2 style="color: #fff; margin-bottom: 15px;">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ EPUB</h2>
            <p style="color: #94a3b8;">${errorMessage}</p>
            <button class="reader-control-btn" onclick="openInSystemViewer('${filePath}')" style="margin-top: 20px;">
                üìÇ –û—Ç–∫—Ä—ã—Ç—å –≤ —Å–∏—Å—Ç–µ–º–Ω–æ–π —á–∏—Ç–∞–ª–∫–µ
            </button>
        </div>
    `;
}

function showUnsupportedFormat() {
    showError('–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞');
}

function showFileNotFound() {
    showError('–§–∞–π–ª –∫–Ω–∏–≥–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω');
}

function showError(message) {
    const textContent = document.getElementById('text-content');
    textContent.innerHTML = `
        <div style="text-align: center; padding: 40px;">
            <div style="font-size: 48px; margin-bottom: 20px;">‚ö†Ô∏è</div>
            <h2 style="color: #fff; margin-bottom: 15px;">–û—à–∏–±–∫–∞</h2>
            <p style="color: #94a3b8;">${message}</p>
        </div>
    `;
}

function showMessage(message, type = 'info') {
    const bgColor = type === 'error' ? '#ef4444' : 
                   type === 'success' ? '#10b981' : 
                   type === 'warning' ? '#f59e0b' : '#3b82f6';
    
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed; top: 20px; right: 20px; background: ${bgColor}; color: white;
        padding: 12px 20px; border-radius: 8px; z-index: 10000; box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        animation: slideIn 0.3s ease; max-width: 400px; font-size: 14px;
    `;
    
    notification.textContent = message;
    document.body.appendChild(notification);
    
    setTimeout(() => {
        notification.remove();
    }, 3000);
}

// ==================== –ù–ê–°–¢–†–û–ô–ö–ò ====================

function setupEventListeners() {
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —á–∏—Ç–∞–ª–∫–∏
    const settingsBtn = document.getElementById('settings-btn');
    const settingsPanel = document.getElementById('settings-panel');
    
    if (settingsBtn && settingsPanel) {
        settingsBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            settingsPanel.classList.toggle('show');
        });
        
        document.addEventListener('click', () => {
            settingsPanel.classList.remove('show');
        });
        
        document.getElementById('font-size').addEventListener('change', (e) => {
            applyFontSize(e.target.value);
        });
        
        document.getElementById('theme').addEventListener('change', (e) => {
            applyTheme(e.target.value);
        });
    }
    
    // –ì–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏
    document.addEventListener('keydown', (e) => {
        switch(e.key) {
            case 'ArrowLeft': case 'PageUp': e.preventDefault(); previousPage(); break;
            case 'ArrowRight': case 'PageDown': case ' ': e.preventDefault(); nextPage(); break;
            case 'Home': e.preventDefault(); showPage(1); break;
            case 'End': e.preventDefault(); showPage(totalPages); break;
            case 'Escape': closeReader(); break;
        }
    });
}

function applyFontSize(size) {
    const textContent = document.getElementById('text-content');
    if (textContent) textContent.style.fontSize = size + 'px';
    saveReaderSettings();
}

function applyTheme(theme) {
    const body = document.body;
    const textContent = document.getElementById('text-content');
    
    body.className = '';
    textContent.className = '';
    
    if (theme !== 'dark') {
        body.classList.add(`theme-${theme}`);
        textContent.classList.add(`theme-${theme}`);
    }
    
    saveReaderSettings();
}

function loadReaderSettings() {
    const settings = JSON.parse(localStorage.getItem('readerSettings') || '{}');
    
    const fontSizeSelect = document.getElementById('font-size');
    const themeSelect = document.getElementById('theme');
    
    if (fontSizeSelect && settings.fontSize) {
        fontSizeSelect.value = settings.fontSize;
        applyFontSize(settings.fontSize);
    }
    
    if (themeSelect && settings.theme) {
        themeSelect.value = settings.theme;
        applyTheme(settings.theme);
    }
}

function saveReaderSettings() {
    const fontSizeSelect = document.getElementById('font-size');
    const themeSelect = document.getElementById('theme');
    
    if (fontSizeSelect && themeSelect) {
        const settings = {
            fontSize: fontSizeSelect.value,
            theme: themeSelect.value
        };
        localStorage.setItem('readerSettings', JSON.stringify(settings));
    }
}

function closeReader() {
    ipcRenderer.invoke('close-reader-window').catch(() => window.close());
}

// –ì–ª–æ–±–∞–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
window.previousPage = previousPage;
window.nextPage = nextPage;
window.closeReader = closeReader;
window.openInSystemViewer = openInSystemViewer;
window.goToPage = goToPage;
window.convertPDFToText = function(filePath) {
    showMessage('OCR —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ', 'info');
};

// –°—Ç–∏–ª–∏
const style = document.createElement('style');
style.textContent = `
    .loading-spinner {
        width: 40px; height: 40px; border: 3px solid #334155; border-top: 3px solid #667eea;
        border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px;
    }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    
    .theme-light { background: #f8fafc !important; color: #1e293b !important; }
    .theme-sepia { background: #fef3c7 !important; color: #78350f !important; }
`;
document.head.appendChild(style);